# Задание:

## Описание
Разработать комплекс программ на пользовательском уровне и уровне ярда, который собирает информацию на стороне ядра и передает информацию на уровень пользователя, и выводит ее в удобном для чтения человеком виде. Программа на уровне пользователя получает на вход аргумент(ы) командной строки (не адрес!), позволяющие идентифицировать из системных таблиц необходимый путь до целевой структуры, осуществляет передачу на уровень ядра, получает информацию из данной структуры и распечатывает структуру в стандартный вывод. Загружаемый модуль ядра принимает запрос через указанный в задании интерфейс, определяет путь до целевой структуры по переданному запросу и возвращает результат на уровень пользователя.

Интерфейс передачи между программой пользователя и ядром и целевая структура задается преподавателем. Интерфейс передачи может быть один из следующих:

syscall - интерфейс системных вызовов.
ioctl - передача параметров через управляющий вызов к файлу/устройству.
procfs - файловая система /proc, передача параметров через запись в файл.
debugfs - отладочная файловая система /sys/kernel/debug, передача параметров через запись в файл.

### Вариант:
syscall{page, mode}
--------------
# PAGE
--------------
В самой структуре есть несколько объединений (unions), которые используются в зависимости от типа страницы. Вот некоторые из этих объединений:

Объединение для страниц кэша и анонимных страниц:

lru: Список страниц, используемых для вытеснения (pageout list), например, активный список (active_list), защищенный pgdat->lru_lock, иногда используется в качестве общего списка владельца страницы.
mapping: Указатель на объект адресного пространства (address_space), с которым связана эта страница.
index: Смещение страницы в пределах объекта адресного пространства.
private: Приватные данные объекта отображения (mapping), используемые для буферных заголовков (buffer_heads) в случае PagePrivate, для swp_entry_t в случае PageSwapCache, а также для указания порядка в системе балансировки buddy (buddy system) в случае PageBuddy.
Объединение для страницы пула, используемое сетевым стеком:

dma_addr: Адрес DMA, который может быть 64-битным на 32-битных архитектурах.
Объединение для страницы слабинга (slab), слоба (slob) и слаба (slub):

slab_list: Список страниц слаба.
next: Указатель на следующую страницу в случае частичных страниц.
pages: Количество оставшихся страниц.
pobjects: Приблизительное количество объектов.
slab_cache: Кэш слаба (не используется в случае слоба).
freelist: Указатель на первый свободный объект.
s_mem: Указатель на первый объект слаба.
counters: Счетчики использования слаба (SLUB).
inuse, objects, frozen: Флаги использования, количества объектов и замороженной страницы (SLUB).
Объединение для хвостовых страниц составной страницы:

compound_head: Бит 0 устанавливается.
compound_dtor, compound_order, compound_mapcount, compound_nr, _pt_pad_2, pt_mm, pt_frag_refcount, ptl: Различные поля, используемые для хвостовых страниц составной страницы.
Объединение для страниц ZONE_DEVICE:

pgmap: Указатель на карту страниц устройства.
zone_device_data: Данные устройства для зоны.
Дополнительные поля, которые используются для анонимных страниц или страниц кэша при их миграции в устройство.
rcu_head: Это поле можно использовать, чтобы освободить страницу с помощью RCU.

В структуре также есть другие поля, такие как _mapcount (количество ссылок на страницу), _refcount (счетчик использования страницы), _last_cpupid (последний идентификатор процессора, использовавшего страницу) и virtual (виртуальный адрес страницы в пространстве ядра).


Не много о том почему встречаются ссылки на пустые страницы в области вирт. памяти процесса: 
--
В 64-битной системе у вас есть более миллиарда гигабайт адресуемого пространства. Ни одно из существующих приложений даже близко не использует такой объем памяти, поэтому в адресном пространстве будут дыры.

Отверстия используются для защиты. Большинство систем оставляют самую нижнюю страницу несопоставленной, чтобы создать ловушку для нулевых указателей. В некоторых системах вокруг штабелей предусмотрены промежутки для улавливания переполнения и потери.

Существует ряд системных адресов. Обычно они зарезервированы, но остается много неиспользуемого пространства. Это создает дыры.

Если вы попытаетесь сохранить непрерывный диапазон пригодных для использования адресов, вы создадите проблему, связанную с необходимостью поддерживать непрерывную память. Это создает всевозможные проблемы с распределением.

------
MODE
---

Я не нашел структуру lsmode в своей версии ядра, потому что это системный вызов который выводит загруженнные модули ядра kernel, поэтому я решил смотреть загруженные участки ядра для определенного процесса 